<#@ template language="C#" hostspecific="true" #>
<#@ Output Extension="cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ parameter type="System.String" name="PartName" #>
<#@ parameter type="System.String" name="Module" #>
<#@ parameter type="System.Boolean" name="SiteSetting" #>
<#@ parameter type="System.String" name="SiteSection" #>
<#@ parameter type="System.Boolean" name="HasSiteGroup" #>
<#@ parameter type="System.Collections.Generic.Dictionary<System.String,System.String>" name="Properties" #>
<#@ parameter type="System.String" name="Feature" #>
<#@ parameter type="System.Boolean" name="HasFeature" #>
using System;
using System.Xml;
using Orchard.ContentManagement;
using Orchard.ContentManagement.Drivers;
using <#= Module #>.Models;
<# if(HasFeature) { #>
using Orchard.Environment.Extensions;
<# } #>

// This code was generated by Orchardizer
namespace <#= Module #>.Drivers
{
<# if(HasFeature) { #>
	[OrchardFeature("<#= Feature #>")]
<# } #>
    public class <#= PartName #>Driver : ContentPartDriver<<#= PartName #>>
    {
        protected override string Prefix
        {
            get { return "<#= PartName #>"; }
        }

<# if(!SiteSetting) { #>
        protected override DriverResult Display(<#= PartName #> part, string displayType, dynamic shapeHelper)
        {
            // Put all your driver logic inside this method so that if your part is not being displayed no logic is run. Yay efficiency
            return ContentShape("Parts_<#= PartName #>", 
                () => { 
                    return shapeHelper.Parts_<#= PartName #>(Model: part);
                });
        }
<# } #>

        protected override DriverResult Editor(<#= PartName #> part, dynamic shapeHelper)
        {
            return ContentShape("Parts_<#= PartName #>_Edit",
                () => shapeHelper.EditorTemplate(
                    TemplateName: "Parts/<#= PartName #>",
                    Model: part,
<# if(SiteSetting && HasSiteGroup) { #>
                    Prefix: Prefix))
                    .OnGroup("<#= SiteSection #>");
<# } else { #>
                    Prefix: Prefix));
<# } #>
        }

        protected override DriverResult Editor(<#= PartName #> part, IUpdateModel updater, dynamic shapeHelper)
        {
            updater.TryUpdateModel(part, Prefix, null, null);
            return Editor(part, shapeHelper);
        }

		protected override void Importing(<#= PartName #> part, ImportContentContext context) {
            var partName = part.PartDefinition.Name;

<#  foreach(var property in Properties) { #>   
			var _<#= property.Key #> = context.Attribute(partName, "<#= property.Key #>");
            if (_<#= property.Key #> != null) {
<# if(property.Value.Contains("bool")) { #>
					part.<#= property.Key #> = Boolean.Parse(_<#= property.Key #>);
<# } else if(property.Value.Contains("string") || property.Value.Contains("String")) { #>
					part.<#= property.Key #> = _<#= property.Key #>;
<# } else if(property.Value.Contains("int")) { #>
					part.<#= property.Key #> = Convert.ToInt32(_<#= property.Key #>);
<# } else if(property.Value.Contains("double")) { #>
					part.<#= property.Key #> = Convert.ToDouble(_<#= property.Key #>);
<# } else if(property.Value.Contains("DateTime")) { #>
					part.<#= property.Key #> = XmlConvert.ToDateTime(_<#= property.Key #>, XmlDateTimeSerializationMode.Utc);
<# } else { #>
					// didn't know what to do... ToString()!
					part.<#= property.Key #> = _<#= property.Key #>.ToString();
<# } #>
			}
<# } #>
		}

		protected override void Exporting(<#= PartName #> part, ExportContentContext context) {
<#  foreach(var property in Properties) { #>   
			context.Element(part.PartDefinition.Name).SetAttributeValue("<#= property.Key #>", part.<#= property.Key #>);
<# } #>
		}
    }
}