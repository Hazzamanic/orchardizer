<#@ template language="C#" hostspecific="true" #>
<#@ Output Extension="cs" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System" #>
<#@ parameter type="System.String" name="FieldName" #>
<#@ parameter type="System.String" name="Module" #>
<#@ parameter type="System.Collections.Generic.Dictionary<System.String,System.String>" name="Properties" #>
<#@ parameter type="System.String" name="Feature" #>
<#@ parameter type="System.Boolean" name="HasFeature" #>
using System;
using Orchard.ContentManagement;
using Orchard.ContentManagement.Drivers;
using Orchard.Localization;
using <#= Module #>.Fields;
using Orchard.ContentManagement.Handlers;
<# if(HasFeature) { #>
using Orchard.Environment.Extensions;
<# } #>

// This code was generated by Orchardizer

namespace <#= Module #>.Drivers {
<# if(HasFeature) { #>
    [OrchardFeature("<#= Feature #>")]
<# } #>
    public class <#= FieldName #>Driver : ContentFieldDriver<<#= FieldName #>> {
		public <#= FieldName #>Driver() {
			T = NullLocalizer.Instance;
        }

        public Localizer T { get; set; }

        private static string GetPrefix(ContentField field, ContentPart part) {
            return part.PartDefinition.Name + "." + field.Name;
        }

        private static string GetDifferentiator(<#= FieldName #> field, ContentPart part) {
            return field.Name;
        }

        protected override DriverResult Display(ContentPart part, <#= FieldName #> field, string displayType, dynamic shapeHelper) {
            // Put all your driver logic inside this method so that if your field is not being displayed no logic is run. Yay efficiency
            return ContentShape("Fields_<#= FieldName #>", GetDifferentiator(field, part),
                () => {
                    return shapeHelper.Fields_<#= FieldName #>(Model: part);
                });
        }

        protected override DriverResult Editor(ContentPart part, <#= FieldName #> field, dynamic shapeHelper) {
            return ContentShape("Fields_<#= FieldName #>_Edit", GetDifferentiator(field, part), 
                () => shapeHelper.EditorTemplate(
                    TemplateName: "Fields/<#= FieldName #>",
                    Model: part,
                    Prefix: Prefix));
        }

        protected override DriverResult Editor(ContentPart part, <#= FieldName #> field, IUpdateModel updater, dynamic shapeHelper) {
            if(updater.TryUpdateModel(field, GetPrefix(field, part), null, null)) {
				// do stuff
			}
            return Editor(part, field, shapeHelper);
        }

        protected override void Importing(ContentPart part, <#= FieldName #> field, ImportContentContext context) {
<#  foreach(var property in Properties) { #>
			context.ImportAttribute(field.FieldDefinition.Name + "." + field.Name, "<#= property.Key #>",
<# if(property.Value.Contains("bool")) { #>
                v => field.<#= property.Key #> = bool.Parse(v));
<# } else if(property.Value.Contains("string") || property.Value.Contains("String")) { #>
                v => field.<#= property.Key #> = v);
<# } else if(property.Value.Contains("int")) { #>
                v => field.<#= property.Key #> = Convert.ToInt32(v));
<# } else if(property.Value.Contains("double")) { #>
                v => field.<#= property.Key #> = Convert.ToDouble(v));
<# } else if(property.Value.Contains("DateTime")) { #>
                v => field.Storage.Set("<#= property.Key #>", XmlConvert.ToDateTime(v, XmlDateTimeSerializationMode.Utc)));
<# } else { #>
                // didn't know what to do... ToString()!
                v => field.<#= property.Key #> = v.ToString());
<# } #>
<# } #>
        }

        protected override void Exporting(ContentPart part, <#= FieldName #> field, ExportContentContext context) {
<#  foreach(var property in Properties) { #>
<#	if(property.Value.Contains("DateTime")) { #>
			context.Element(GetPrefix(field, part)).SetAttributeValue("<#= property.Key #>", XmlConvert.ToString(field.Storage.Get<DateTime>("<#= property.Key #>"), XmlDateTimeSerializationMode.Utc));
<# } else { #>			
			context.Element(field.FieldDefinition.Name + "." + field.Name).SetAttributeValue("<#= property.Key #>", field.<#= property.Key #>);
<# } #>
<# } #>
        }

		protected override void Describe(DescribeMembersContext context) {
			// .Member() will index these properties in the Projections module and allow you to filter on field values
			// .Enumerate will index these properties for search
            context
<#  
int i = 0;
foreach(var property in Properties) { 
if(i == 0) {
#>
                .Member(null, typeof(<#= property.Value #>), T("<#= property.Key #>"), T("Description for the <#= property.Key #> value of the field."))
<# } else { #>
				.Member("<#= property.Key #>", typeof(<#= property.Value #>), T("<#= property.Key #>"), T("Description for the <#= property.Key #> value of the field."))
<# } i++; } #>
                .Enumerate<<#= FieldName #>>(() => field => new[] { 
<#  
int j = 0;
foreach(var property in Properties) { 
if(j == 0) {
#>
					field.<#= property.Key #>
<# } else { #>
					, field.<#= property.Key #>
<# } j++; } #>
				});
        }
    }
}